## Структура репозитория
* ava_dataset_prepare – директория, посвященная подготовке датасета [Ava Spoken Activity](http://research.google.com/ava/)
* calc_val_metrics – директория, посвященная вычислению метрик для моделей на датасетах [LibriSpeech](https://www.openslr.org/12) и [Ava Spoken Activity](http://research.google.com/ava/)
* demo – директория, посвященная демонстрации работы моделей
* librispeech_dataset_prepare – директория, посвященная подготовке датасета [LibriSpeech](https://www.openslr.org/12)
* predicts – директория с результатами предсказаний на тестовом датасете
* src – директория с исходным кодом для обучения и валидации
* 2b4pjq8n_thresholds.csv – таблица с результатами проверки значений метрик FA и FR для разных трешхолдов модели
* find_threshold.py – скрипт для поиска соответствующих трешхолдов
* inference.py – скрипт для предсказания с помощью модели
* requirements.txt – пакеты, необходимые для работы
* train.py – скрипт для обучения модели

## Инструкция по обучению
1. Установить пакеты, указанные в requirements.txt
2. Подготовить датасеты с помощью скриптов из librispeech_dataset_prepare
   1. Скачать необходимые части датасета [LibriSpeech](https://www.openslr.org/12)
   2. Установить [mfa](https://montreal-forced-aligner.readthedocs.io/en/latest/first_steps/example.html#alignment-example)
   3. Воспользоваться get_alignments.py для получения выравниваний на основе датасета
   4. Воспользоваться parse_alignments.py для преобразования выравниваний в более удобный формат
   5. С помощью split_dataset.py можно разделить датасет на тренировочную и валидационную подвыборки
3. Запустить обучение с помощью train.py

## Инструкция по запуску
1. Воспользоваться inference.py

## Краткий обзор существующих методов
Очень полезной для составления обзора существующих методово оказалась статья от [MarbleNet](https://arxiv.org/pdf/2010.13886.pdf) от Nvidia 2021 года.
В ведении дается много разнообразных ссылок на предыдущие решения задачи VAD (к сожалению, многих статей нет в открытом доступе):
1. Решения не основанные на машинном обучении (классификация очень условная, потому что данные категории сильно пересекаются)
   1. Построение признаков "руками"
   2. Использование статистических признаков
2. Решения, основанные на использовании машинного обучения
   1. Полносвязные сети
   2. Рекуретные сети
   3. Сверточные сети
   4. Трансформеры

И разумеется различные комбинации всех вышеизложенных архитектур. 
   
Самым простым способом решить задачу VAD – посчитать спектральную мощность. Однако такой подход никак не учитывает особенности человеческой речи, 
поэтому абсолютно бесполезен в реальном приложении, так как будет активироваться не на голос, а на любой шум. Поэтому методы, не основанные на 
машинном обучении стремятся выделить особенности человеческой речи и использовать их. [Статья 1](https://www.diva-portal.org/smash/get/diva2:831566/FULLTEXT01.pdf)
[Статья 2](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.364.4084&rep=rep1&type=pdf)

Рекуретные сети по своей природе должны хорошо справляться с последовательной информацией, однако они медленные и их обучение усложняется
"насыщением активаций" [Gregory Gelly,2018](http://www-tlp.limsi.fr/public/talsp2018-gelly08100927.pdf). В противовес им можно использовать
сверточные сети, которые подходят к вопросу моделированию последовательностей совсем иначе (
часто ссылаются на [Shuo-Yiin Chang et al.,2018](https://ieeexplore.ieee.org/document/8461921), однако не смог найти в открытом доступе, но идея 
вроде бы понятна и по абстракту). Упоминаемая выше [MarbleNet](https://arxiv.org/pdf/2010.13886.pdf) тоже основана на сверточных слоях.
А например [CLDNN](https://repositorio.uam.es/bitstream/handle/10486/675731/feature_zazo_INTERSPEECH_2016.PDF;jsessionid=809F5B081B34627D680C102A311F3932?sequence=1)
сочетает использование и сверточных слоев, и рекуретных.

## Краткое описание выбранной архитектуры
Так как задача формулировалась как потоковая, то был выбран подход с использованием реккуретных сетей, как более простой в реализации.
Вдохнавляясь [Perconal VAD](https://repositorio.uam.es/bitstream/handle/10486/675731/feature_zazo_INTERSPEECH_2016.PDF;jsessionid=809F5B081B34627D680C102A311F3932?sequence=1)
, [Real-life voice activity detection with LSTM](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.364.4084&rep=rep1&type=pdf), [советами](https://danijar.com/tips-for-training-recurrent-neural-networks/)
по обучению рекуретных сетей и ШАДовским курсом по речевым технологиям, я собрал следующую модель:
* Из звуковой записи выделяются акустические признаки (Мелспектрограммы)
* Линейный слой проецирует признаки в более сжатое пространство
* Сжатые признаки подаются в рекуретные GRU блоки с дропаутом и нормализацией. 
* Полученные состояния отображаются в двумерное пространство (чтобы вместо nn.BCE можно было использовать nn.CrossEntropyLoss,
который позволяет более просто работать с паддингами)

Более подробно с моделью можно ознакомится в src/model.py

Основной метрикой была выбрана FA – доля ошибочных срабатываний. Я ее выбрал, так как модели VAD, как я понял часто используются 
как триггер для более тяжелых моделей, например распознавания речи. Поэтому мне показалось, что очень важно понизить число ложных срабатываний. 
Число пропусков срабатывания (FR) также очень важно, так как при большом количестве ошибок следом идущие системы не будут выполнять свои функции, 
однако я исходил из соображений, что речь -- продолжительный процесс и небольшое запаздывание или пропуск коротких фраз допустим.

## Найденные трешхолды

Двоичным поиском были найдены следующие пороги:
* FA=0.01: 0.625
* FR=0.01: 0.125
* FA=FR: 0.4062

Для ускорения поиска значения метрик округлялись до третьего знака после запятой

|th    |fa   |fr   |
|------|-----|-----|
|0.5   |0.015|0.024|
|0.75  |0.007|0.036|
|0.625 |0.01 |0.029|
|0.25  |0.031|0.014|
|0.125 |0.06 |0.008|
|0.1875|0.04 |0.012|
|0.375 |0.021|0.019|
|0.4375|0.017|0.021|
|0.4062|0.019|0.02 |


## Сравнение полученной модели с WebRTC VAD
WebRTC VAD является очень хорошей реализацией системы, которая не используется машинное обучение – она создавалась с прицелом на то, чтобы 
быть легкой, быстрой и потоковой. И разработчикам это удалось. Поэтому сравнивать его по скорости с моим решением, которое использует 
машинное обучение, бесполезно (по ощущениям разница измеряется в порядках). Поэтому упор делался на качестве, гибкости и устойчивости к шуму.

Обычным подходом является генерация синтетического датасета – на чистый звук накладываются дополнительные шумы. Однако 
самый популярный датасет шумов использовать было нельзя.

Поэтому в качестве данных с шумом использовался датасет [AVA](http://research.google.com/ava/).
От либриспича он отличается следующим:
* Мало данных (около 24 часов против 960 часов)
* Ручная разметка (в отличие от разметки, основанной на жестком выравнивании) 
* Составлен на основе видео, поэтому речь более естественная и содержит шумы (в отличие от голосов дикторов в либриспиче) 

Поэтому такой датасет очень хорошо подошел для валидации.

### Валидационная подвыборка LibriSpeech
30% от train-clean-100 + train-clean-360 + train-other-500.

Соотношение кадров без речи/с речью: 0.177/0.823

Результаты моей модели (th – трешхолд) :

|th    |fa| fr |
|------|-------|----------|
|0.4062|0.019  | 0.02     |
|0.625 |0.01   | 0.029    |
|0.95  |0.002  | 0.067    |

Результаты WebRTC VAD (aggr – "агрессивность"):

|aggr  |fa|fr|
|------|--------|-------|
|0     |0.119   |0.011  |
|1     |0.108   |0.013  |
|2     |0.074   |0.02   |
|3     |0.019   |0.078  |

### Датасет AVASpeech
15-ти минутные отрывки фильмов с [ручной разметкой](https://arxiv.org/abs/1901.01342) на 4 класса:
* Без голоса
* Чистый голос
* Голос с шумом
* Голос с музыкой

Соотношение кадров без речи/с речью: 0.477/0.523

Результаты моей модели (th – трешхолд) :

|th    |fa|fr_clean|fr_noise|fr_music|
|------|--------|--------|--------|--------|
|0.4062|0.329   |0.018   |0.017   |0.008   |
|0.625 |0.308   |0.02    |0.022   |0.01    |
|0.95  |0.265   |0.028   |0.035   |0.017   |
|0.97  |0.255   |0.031   |0.039   |0.019   |
|0.99  |0.23    |0.036   |0.05    |0.025   |


Результаты WebRTC VAD (aggr – "агрессивность"):

|aggr  |fa|fr_clean|fr_noise|fr_music|
|------|-------|--------|--------|--------|
|0     |0.36   |0.012   |0.014   |0.007   |
|1     |0.327  |0.014   |0.02    |0.009   |
|2     |0.247  |0.021   |0.041   |0.021   |
|3     |0.017  |0.091   |0.204   |0.115   |

Реализованный подход, значительно проигрывая в быстродействии, к сожалению не выигрывает в качестве и устойчивости к шуму в той же мере. 
Однако нельзя не отметить наличие какого-то прироста в качестве, а также в целом бОльшую гибкость подхода с использованием машинного обучения.

## Colab-demo
[Статичный](https://colab.research.google.com/drive/16rt_MDeoLaQIdQHuRKOquL8f8h67-iJP?usp=sharing)

[Интерактивный](https://colab.research.google.com/drive/1fQMeTEGvxBvKhJaBji8fkZ-bE2owVuh-?usp=sharing)
## Использованные статьи/репозитории/etc
[1](https://arxiv.org/pdf/2010.13886.pdf), [2](https://www.diva-portal.org/smash/get/diva2:831566/FULLTEXT01.pdf),
[3](https://arxiv.org/pdf/1808.00606.pdf), [4](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.364.4084&rep=rep1&type=pdf),
[5](https://storage.googleapis.com/pub-tools-public-publication-data/pdf/bbd259619fdae1b2e8108348753c91c4a8f081fd.pdf), 
[6](https://repositorio.uam.es/bitstream/handle/10486/675731/feature_zazo_INTERSPEECH_2016.PDF;jsessionid=809F5B081B34627D680C102A311F3932?sequence=1),
[7](http://www-tlp.limsi.fr/public/talsp2018-gelly08100927.pdf),
[8](https://danijar.com/tips-for-training-recurrent-neural-networks/), 
[9](https://gist.github.com/NTT123/12264d15afad861cb897f7a20a01762e)
